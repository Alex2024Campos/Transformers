>[!Important]
 > ` - Transformers (2007) | Transformers, The Fight:`
>- Turma: 2°Mtec Desenvolvimento de Jogos Digitais.
>- Escola: Etec Prof. Basilides de Godoy.
>- Sobre: Repositório para a documentação do jogo Transformers, um trabalho proposto pelas professoras Aline Firmino Brito e Nivia Maria Domingues, da Etec Prof. Basilides de Godoy.
>- Datas: Apresentar o jogo (terça-feira que vem, 26/11/2024).
>- Projeto (drive): https://drive.google.com/drive/folders/1_ls9ojh6CY0qQvsZfG7ksWS_e6w3Heri?usp=sharing

>[!Important]
 > ` - Dupla:`
>- Alex Campos de Oliveira
>- Felipe Mussato Rodrigues

> [!NOTE]
 > `- Alterações do Jogo:`
 >- `Acrescento de um projétil.`
 >- `Exclusão dos estilos de luta e variação do inimigo (mudar vida, etc).`
>- `Mudança nos personagens principais.`

> [!NOTE]
>- `Gameplay`:


https://github.com/user-attachments/assets/ae072a84-024d-403f-9326-24b056dadf9a


_________________________________________________________________
# Descrições:

## Descrição da Obra:
- Transformers (2007) explora a relação entre humanos e tecnologia, mostrando o impacto desse encontro em uma batalha épica pelo destino da Terra. No centro da história está o AllSpark, uma fonte de energia capaz de criar e destruir, refletindo o potencial criador e destruidor da própria tecnologia. Os Autobots e Decepticons, liderados por Optimus Prime e Megatron, representam o clássico embate entre o bem e o mal, onde os primeiros buscam proteger, e os segundos dominar; e os mesmos buscam o AllSpark com objetivos diferentes, logo o enredo da história é desenvolvido de acordo com essa trama.
 A jornada de Sam Witwicky, um jovem comum que se vê no centro desse conflito ao lado de Bumblebee, simboliza a descoberta de responsabilidade e amadurecimento em meio ao caos. Mais que um espetáculo visual, a obra traz uma visão humanizada das máquinas e questiona como tecnologia e humanidade podem coexistir, sugerindo que, mesmo em seres de metal, há valores e lealdades. O filme une o espetacular e o banal ao mostrar que o herói pode vir de qualquer lugar, até mesmo de um adolescente desajeitado.       
 Embora robôs, os Autobots têm personalidades, valores e emoções, especialmente Bumblebee, que cria um vínculo de amizade com Sam. Isso sugere que, apesar de sua origem alienígena e mecânica, a essência dos Autobots é profundamente semelhante à humana; em contraste com os Decepticons, que representam o lado mais sombrio e destrutivo da tecnologia. O filme também reavivou a franquia Transformers e deixou um marco na cultura popular.
<br>

##  Descrição da Cena:
- Na cena, Sam e Mikaela acompanhado o Bumblebee vão desesperadamente até um depósito de carros abandonado, fugindo de Barricade, um Decepticon. Bumblebee para bruscamente e se transforma de Camaro em robô, pronto para defender os humanos. O confronto é intenso, com Bumblebee e Barricade trocando golpes poderosos entre pilhas de carros sucateados. Durante a batalha, Barricade lança um pequeno robô( chamado Mini-Cons), rápido e ágil, que avança em direção a Sam e Mikaela. Bumblebee luta para proteger os dois, enfrentando o Barricade, enquanto o pequeno robô tenta capturar o Sam. A cena atinge seu clímax quando Bumblebee derrota Barricade, e Mikaela e Sam conseguem eliminar o pequeno robô.
<br>

## Teoria das Cores (Obra):
- A teoria das cores na obra é aplicada de forma cuidadosa para transmitir características e sentimentos dos personagens e ambientações. Cada cor reforça traços de personalidade, criando uma identificação emocional e visual clara para cada personagem e cenário. Os Autobots são caracterizados por cores vibrantes e mais saturadas; Bumblebee em amarelo brilhante, Optimus Prime em azul e vermelho intensos. Essas cores representam heroísmo, vitalidade e calor, associando os Autobots a qualidades positivas e acessíveis. Em contraste, os Decepticons.
 Decepticons: Os Decepticons têm tons de cinza e prata metálico, criando um visual frio e ameaçador. A ausência de cores vivas nos Decepticons reforça sua impessoalidade e crueldade, simbolizando a falta de compaixão e a ambição destrutiva. Esses tons neutros e frios contrastam com as cores vibrantes dos Autobots, marcando-os como uma presença hostil e perigosa.
 Cenários: Muitos dos cenários são urbanos e cinzentos, com tons industriais que reforçam o clima de ameaça e tensão no filme. O cinza predominante no ambiente reflete um mundo comum e neutro, que ganha vida e caos com a chegada das máquinas coloridas e metálicas.
<br>

## Teoria das Cores (Cena):
- No ambiente sombrio e desbotado do depósito, o amarelo vibrante de nosso protagonista se destaca e serve como forma de enfatizar sua presença protetora e heroica. O contraste do ambiente com a cor do personagem reforça o seu papel como defensor, trazendo o seu elemento de segurança e confiança visual. Para se contrastar com Bumblebee, teremos o principal inimigo, lacaios Decepticons enviados por Barricade para capturar Sam e que contarão com tons escuros, metálico e ferrugem, passando uma sensação de ameaça constante. As cores frias fazem dele uma figura intimidante e perigosa, especialmente quando combinado com o ambiente sombrio do depósito, destacando seu papel como inimigo e ameaça. Por fim, o cenário é dominado por cores desgastadas e metálicas, com tons de cinza, marrom e ferrugem, criando uma sensação de abandono e isolamento e tornando o confronto entre Bumblebee e os lacaios de Barricade ainda mais intenso.
<br>

## Análise dos Protagonistas:
- Sam Witwickyt:
 Sam é um jovem que tem uma paixão por Mikaela e, ao menos no começo do filme, quer muito um carro para tentar atrair alguém com isso. No decorrer da trama, ele acaba se aproximando de quem gostava e criando uma relação próxima com Bumblebee, o qual foi seu primeiro carro e que o defendeu em diversas ocasiões. Sam continha um óculos de seu avô que serviria como um tipo de mapa até o cubo, um objeto almejado por Megatron. Enfim, ele começa a trama sendo um jovem meio esquisito, covarde e também introvertido, mas com o decorrer dela ele começa a se tornar alguém mais confiante e até mesmo acaba ficando com Mikaela.

- Mikaela:
 Mikaela, como Sam, é uma jovem que acaba conhecendo o protagonista do filme no começo dele ao precisar de uma carona para voltar para casa, voltando a aparecer mais pra frente do filme somente (na cena em que Sam está fugindo de Bumblebee, pois não o conhecia naquele momento). Ela acaba por se aproximar mais do herói do filme quando os dois estão sendo perseguidos por um Decepticon, mas sendo salvos por Bumblebee, e curiosa com tudo aquilo ela acaba unindo forças com os dois. Ela é uma ex-criminosa e sabe bastante de carros devido ao seu pai que ensinou tudo que sabia a ela e a levou em alguns "serviços" (roubar carros), dai o histórico criminal dela, mas o mesmo acaba sendo "apagado" após ela ajudar o governo a lutar contra os Decepticons.

- Meg: 
 É uma das pessoas jovens que acaba aderindo ao serviço de defesa americano e que foi de grande ajuda ao descobrir sobre o que teria atacado a base do Qatar (no caso, os soldados de Megatron). Meg também foi presa após levar alguns dados confidenciais a um colega dela na tentativa de descobrir o que é que fosse aquela frequência. No fim, ela acaba sendo chamada para ajudar na luta contra os Decepticons. 
 
- Bumblebee:
 O carro de Sam, Bumblebee acaba sendo importantíssimo na luta contra Megatron e na missão de esconder ou destruir o cubo de Optimus Prime, até mesmo salvando Sam em diversas situações. Inicialmente, ele se mantém camuflado como um carro até que Sam e Mikaela acabem descobrindo ele e depois o que seria ele. Ele é um dos membros do grupo de Optimus Prime e é quem protege o cubo até ele ser dado para o protagonista. 

- Sargento Lennox:
 O Sargento Lennox é um dos militares sobreviventes do ataque a base do Qatar e também um dos personagens que estiveram na luta contra Megatron e seu grupo, tendo ajudado ao conseguir alguns dados (imagem e um dos que sobreviveram à luta contra o Decepticon) sobre os "aliens" que estavam invadindo a Terra. Além disso, ele ajuda Sam a conseguir libertar o Bumblebee ao ser capturado pelo governo para ser pesquisado e serem feitos testes nele.
<br>

## História do Jogo:
- Sam e Mikaela, fugindo de um Decepticon, fogem de forma desesperada até um depósito de carros abandonado. Então, o Autobot, antes transformado em carro e que estava a ajudar os dois a fugir do inimigo, freia bruscamente e se transforma em robô, pronto para defender os humanos. O confronto é intenso, com o Autobot trocando golpes poderosos com o Decepticon e seus "minions" (inimigos menores, os quais estão auxiliando o inimigo da cena a lutar contra nosso jogador) em meio as pilhas de carros sucateados.
_________________________________________________________________

# Mecânica do Jogo:
- O jogo contará com algumas mecânicas, sendo elas: pontuação, hordas de inimigos e variação dentre os tipos de inimigos. Especificando melhor cada:
 - Pontuação: Cada inimigo destruído pelo nosso jogador, nesse caso o Autobot, gerará pontos para o mesmo. O objetivo do jogador é se manter vivo enquanto tenta atingir o máximo de pontuação possível.
   
 - Hordas de inimigos: Um sistema de "wave", o qual ditará a quantidade de inimigos que serão gerados durante a cena com base no valor atual da horda, o qual se altera com base na destruição de todos os inimigos na cena. Ou seja, sempre que você eliminar uma horda de inimigos inteira, a wave terá o acrescento de +1, multiplicando a quantidade de inimigos presentes no mapa.
<br>


# Classes do Jogo:
As classes do jogo são: "Jogador", "Inimigo", "Wave" e "Menu". Abaixo estará melhor detalhadas essas classes:

- Jogador: 
 A classe jogador serve como um molde para o nosso player, atribuindo-lhe algumas informações como: velocidade, frequência de disparo, pontuação, dentre outros. O jogador será capaz de disparar projéteis de fogo para eliminar os robôs inimigos.

- Inimigo:
 No contexto de nosso jogo, a classe inimigo servirá para fornecer algumas informações que serão utilizadas de base para outros métodos de outros scripts. Através da classe wave, criaremos novas instâncias do inimigo do jogo, as quais serão cada vez maiores conforme as waves forem passando.

- Wave:
 A Wave serve como uma forma de monitorar e administrar o Spawn de instâncias do prefab do inimigo, utilizando-se de alguns métodos para identificar o Spawn e a passagem de wave (que aumentará o valor de inimigos a serem criados). Utilizamos também da coroutine para criar um tipo de "timer" dentre a criação de uma wave (ou seja, passou da 1° wave pra segunda, será dado um tempo para que os códigos dentro dela sejam efetuados novamente).

- UI:
 A classe menu serve unicamente para identificar os cliques do jogador no nosso menu e assim atribuir a cena do botão respectivo. 
<br>


_________________________________________________________________

# Codificação do Jogo:
 Abaixo teremos os códigos do nosso projeto e uma explicação mais detalhada das principais linhas de códigos deles.

- Enemy:
```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Enemy : MonoBehaviour
{
    Animator animator; // Animator do inimigo
    private float speed = 5f; // Variável para a velocidade do inimigo
    private CharacterController characterController; / CharacterController do inimigo
    public GameObject player; // Puxa o objeto "Jogador"
    public GameObject explosionEffect; // Puxa o efeito de explosão
    public float explosionHeightOffset = 1f; //  
    private float gravity = -9.8f; // Variável para a gravidade do inimigo (usado para faze-lo ficar no chão)
    private float verticalVelocity; // Variável usada para caso o inimigo esteja no ar, ele caia e fique no chão
    public Wave waveManager; // Variável que puxa os elementos públicos da Wave
    public Player playerScript; // Variável que puxa os elementos públicos do Jogador

    [System.Obsolete]
    void Start()
    {
        animator = GetComponent<Animator>(); //Pega o animator do inimigo
        characterController = GetComponent<CharacterController>(); // Pega o controller do inimigo
        playerScript = FindObjectOfType<Player>(); //Atribue o player à variável playerScript

    }

    void Update()
    {
       

        Vector3 direction = (player.transform.position - transform.position).normalized; // Determina a direção do inimigo com base na posição do jogador

        Quaternion lookRotation = Quaternion.LookRotation(direction); // Direciona o rotacionamento do inimigo
        transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 5f); // Aplica a rotação ao inimigo

        if (characterController.isGrounded) // Verifica se o inimigo está no chão, se estiver ele deixa a velocidade de queda em zero, senão, utiliza do Gravity e Time.deltaTime para determinar a velocidade vertical dele e assim deixa-lo no chão
        {
            verticalVelocity = 0;
        }
        else
        {
            verticalVelocity += gravity * Time.deltaTime; 
        }

        Vector3 move = direction * speed * Time.deltaTime;
        move.y = verticalVelocity * Time.deltaTime; 
        characterController.Move(move);

        bool isMoving = direction.magnitude > 0.1f; // Ditará se o jogador estará se movendo para atribuir a animação "Walk", caso seja null, a animação será "Idle"
        if (animator != null) // Se existir um animator (ou seja, não for nulo), irá atribuir as animações abaixo ("Walk"[isMoving] , "Idle [!isMoving]")
        {
            animator.SetBool("Walk", isMoving);
            animator.SetBool("Idle", !isMoving);
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player")) // Verifica se o objeto em que o inimigo está colidindo é igual à "Player" e caso seja, puxa o método "Explode()" do próprio inimigo e um do player, o "TakeDamage()" que causará dano ao jogador
        {
            playerScript.TakeDamage();
            Explode();

        }

        if (other.CompareTag("Projectile")) // Verifica se a tag do objeto em que o inimigo está colidindo é igual à "Projectile", se for verdadeiro, puxará o metódo "AddPoints(10f)", com um parâmetro de 10f que serão acrescentados na pontuação do jogador e o "Explode()"
        {
            playerScript.AddPoints(10f);
            Explode();
        }
    }

    public void Explode() 
    {
        if (explosionEffect != null) // Verifica se o efeito de explosão é diferente de nulo e caso seja, executará os códigos abaixos que determinam a posição do efeito de explosão (aonde será feita a explosão) e instancia o efeito de explosão na posição determinada no vector3. Além disso, o gameObject será destruído (o qual utiliza de base para determinar qual objeto vai destruir o OnTriggerEnter)
        {
            Vector3 explosionPosition = transform.position + Vector3.up * explosionHeightOffset;
            Instantiate(explosionEffect, explosionPosition, Quaternion.identity);
        }
        Destroy(gameObject);
    }

    public void OnDestroy() //Método do próprio Unity que serve como uma forma de avisar ao script de Wave que um inimigo foi morto
    {
        waveManager.EnemyKilled();
    }
}
```

- Player:
```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class Player : MonoBehaviour
{
   using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using Unity.VisualScripting;

public class Player : MonoBehaviour
{
    public int lives = 3; // número de vidas do jogador
    public float points = 0f; // pontuação inicial do jogador
    public TMP_Text pointsText; // referência ao elemento de texto para mostrar a pontuação
    public TMP_Text livesText; // referência ao elemento de texto para mostrar as vidas restantes
    public GameObject gameOverScreen; // tela de "Game Over"
    public GameObject pauseMenu; // menu de pausa

    public GameObject projectilePrefab; // prefab do projétil para tiros
    public Transform shootPoint; // ponto de origem do disparo
    public float projectileSpeed = 20f; // velocidade do projétil
    public float fireRate = 0.5f; // tempo mínimo entre disparos
    private float lastShotTime; // marca de tempo do último disparo

    private Animator animator; // controlador de animação
    public CharacterController controller; // componente responsável pelo movimento do jogador
    public Transform playerObj; // objeto do jogador para rotação
    public Transform cam; // transform da câmera para referência de direção
    public float moveSpeed = 5f; // velocidade de movimento do jogador
    public float gravity = -9.81f; // intensidade da gravidade
    private Vector3 velocity; // velocidade do jogador
    private bool isGrounded; // indica se o jogador está no chão

    private bool isPaused = false; // estado de pausa do jogo

    private void Start() // função de start
    {
        UpdateUI(); // starta função de update do UI
        gameOverScreen.SetActive(false); // desativa o tela de gameover
        pauseMenu.SetActive(false); // desativa a tela do menu de pausa
        animator = GetComponent<Animator>(); // obtem o componente do animator para utiliza-lo

    }

    private void Update() // função de update
    {
        Pause(); // chama a função de pausa

        if (Input.GetMouseButton(0) && Time.time >= lastShotTime + fireRate)  // controle do tiro
        {
            FireProjectile(); // atira
            lastShotTime = Time.time; // atualiza o tempo até o último disparo
        }

        isGrounded = controller.isGrounded; // controle de gravidade

        if (isGrounded && velocity.y < 0) // controle de movimento e gravidade
        {
            velocity.y = -2f; // reseta a velociade vertical ao tocar o chão
        }

        // obtem as entradas do jogador 
        float horizontalInput = Input.GetAxisRaw("Horizontal"); // obtem os inputs horizontais do jogador
        float verticalInput = Input.GetAxisRaw("Vertical"); // obtem os inputs verticais do jogador

        // determina a direção de movimento baseada na câmera
        Vector3 forward = new Vector3(cam.forward.x, 0, cam.forward.z).normalized; 
        Vector3 right = new Vector3(cam.right.x, 0, cam.right.z).normalized;
        Vector3 moveDir = (forward * verticalInput + right * horizontalInput).normalized;

        controller.Move(moveDir * moveSpeed * Time.deltaTime); // move o jogador

        velocity.y += gravity * Time.deltaTime; // aplica a gravidade
        controller.Move(velocity * Time.deltaTime);

        bool isMoving = moveDir.magnitude > 0.1f; // 
        if (animator != null) // se existir uma animação, ou seja, for diferente de nula
        {
            animator.SetBool("Run", isMoving); // ativa ou desativa a animação com base no boolean
            animator.SetBool("Idle", !isMoving); // ativa ou desativa a animação com base no boolean
        }

        LookAtMouse(); // chama a função de olhar para o mouse
    }

    private void LookAtMouse() // função de olhar para o mouse
    {
        // raycast é uma linha imaginaria com um ponto de origem e uma direção
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); // camera.main = se refere a camera principal ; ScreenPointToRay(Input.mousePosition) = converte a posição do mouse na tela para uma linha imaginaria que parte da camera principal para o espaço 3D ; Input.mousePosition = obtem a posição do cursor do mouse em coordenadas da tela 
        if (Physics.Raycast(ray, out RaycastHit hitInfo)) // Physics.Raycast() = lança um raio, verifica se colidiu com algum objeto com colisor e retorna true se houver colisão e false se não ; out RaycastHit hitInfo = se o raio colidir com algo, as informações sobre o ponto de impacto são armazenadas na variável hitInfo do tipo RaycastHit ; out significa que essa variável será preenchida com os dados do impacto ; ray é o raio
        {
            Vector3 targetPoint = hitInfo.point; // ponto onde o raio atinge
            Vector3 lookDirection = targetPoint - playerObj.position; // calculo para saber a direção de olhar com base na position do player
            lookDirection.y = 0; // ignora rotação no eixo y 
            playerObj.rotation = Quaternion.LookRotation(lookDirection); // atualiza a rotação do jogador
        }
    }

    void FireProjectile() // função de atirar o projétil 
    {
        if (projectilePrefab == null || shootPoint == null) return; // se o alguma dessa variáveis for nula ele encerra a execução da função
        GameObject projectile = Instantiate(projectilePrefab, shootPoint.position, shootPoint.rotation); // instancia o projétil
        Rigidbody rb = projectile.GetComponent<Rigidbody>(); // obtem o componente de rigidbody para controlar ele
        if (rb != null) // se existir um rigidbody, ou seja, se for diferente de nulo
        {
            rb.velocity = shootPoint.forward * projectileSpeed; // define a velocidade do projétil
        }
        Destroy(projectile, 5f); // destrói o prójetil após 5 segundos
    }

    private void Pause() // função de pausa do jogo
    {
        if (Input.GetKeyDown(KeyCode.Escape)) // se a tecla de escape(ESC) for pressionada
        {
            isPaused = !isPaused; // transforma o boolean em verdadeiro, falando que está pausado

            if (isPaused) // se estiver pausado
            {
                Time.timeScale = 0f; // o tempo para enquanto está pausado
                pauseMenu.SetActive(true); // ativa o menu de pausa
            }
            else // senão
            {
                Time.timeScale = 1f; // o tempo volta a andar novamente
                pauseMenu.SetActive(false); // desativa o menu de pausa
            }
        }
    }

    public void TakeDamage() // função que serve para dar dano ao jogador
    {
        lives--; // reduz as vidas do personagem

        if (lives <= 0) //se as vidas forem menor ou igual a 0
        {
            GameOver(); // chama a função de gameover
        }
        else  // senão
        {
            UpdateUI(); // chama função de atualizar a UI
        }
    }

    public void AddPoints(float amount) // função de adicionar os pontos, cria um parametro float de quantidade
    {
        points += amount; // Adiciona a pontuação
        UpdateUI();  // Atualiza a UI
    }

    private void UpdateUI() // função de atualizar a UI
    {
        pointsText.text = "Points: " + points.ToString(); // Atualiza o texto de pontuação e transforma os pontos em texto
        livesText.text = "Lives: " + lives.ToString(); // Atualiza o texto de vidas e transforma as vidas em texto
    }

    private void GameOver() // funcão de derrota
    {
        gameOverScreen.SetActive(true); // Ativa a tela de gameover
        Time.timeScale = 0f; // Para o tempo para evitar que o jogo rode, enquanto no gameover
    }
}
```
- Projectile
```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Projectile : MonoBehaviour
{
    private void OnTriggerEnter(Collider other) // Se houver uma colisão com o projétil do jogador, executará os códigos abaixo:
    {
        if (other.CompareTag("Enemy")) // Verifica se a tag do objeto é igual a "Enemy"
        {

            Enemy enemyScript = other.GetComponent<Enemy>(); // Pega o script do inimigo para usar do método "Explode"
            if (enemyScript != null) // Se o script do inimigo for diferente de null, ou seja, existir no GameObject acertado, fará a linha de código abaixo
            {
                enemyScript.Explode(); // Puxa o método "Explode" do inimigo
            }
            Destroy(gameObject); // Destroe o GameObject se o CompareTag for verdadeiro
        }
    }
}
```

- Wave:
```csharp
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class Wave : MonoBehaviour
{
    public GameObject enemyPrefab; // Prefab do inimigo
    public Transform[] spawnPoints; // Array dos spawnPoints (aonde o inimigo será spawnado)
    public TMP_Text waveText; // Elemento de texto que aparece na tela
    private int currentWave = 1; // Wave atual
    private int enemiesToSpawn = 2; // Inimigos para serem spawnados na wave
    private int enemiesAlive = 0; // "Verificador" (serve para determinar se terão inimigos na cena ou não)

    private void Start()
    {
        UpdateWaveText(); // Inicia a Coroutine
        StartCoroutine(SpawnWave()); // Inicia a atualização do texto de valor da wave (é visível dentro do jogo)
    }

    private IEnumerator SpawnWave() // Serve para criar um "Delay" de uma wave para outra e instanciar os objetos já predefinidos dentro do script. Utiliza de um array "spawnPoints" para criar várias posições em que os objetos poderão ser spawnados
    {
        yield return new WaitForSeconds(2f); // Time

        for (int i = 0; i < enemiesToSpawn; i++) // Verifica se i é menor que o valor de inimigos para spawnar, assim se for, repetirá a instanciação dos objetos até chegar ao valor de inimigos que estão na cena (é tipo um parâmetro: tem 3 inimigos para spawnar, será instanciado até que i seja igual à 3, ou seja, criará 3 objetos)
        {
            Transform spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)]; // Determina a posição do spawnPoints de forma aleatória
            Instantiate(enemyPrefab, spawnPoint.position, spawnPoint.rotation); // Instancia o prefab do inimigo utilizando a posição randomizada do "spawnPoint"

            enemiesAlive++; 
            yield return new WaitForSeconds(0.5f); // Time
        }
    }

    public void EnemyKilled()
    {
        enemiesAlive--; // Diminue o valor de inimigos vivos
        if (enemiesAlive <= 0) // Verifica se o valor de inimigos vivos no cenário é maior que 0, senão, chamará o método "AdvanceWave()"
        {
            AdvanceWave(); // Avança a wave, aumenta a quantidade de inimigos, recomeça a Coroutine e atualiza o valor de wave aparecendo na tela
        }
    }

    private void AdvanceWave() 
    {
        currentWave++; // Aumenta o valor da wave atual
        enemiesToSpawn += 3; // Aumenta o valor de inimigos para spawnarem
        UpdateWaveText(); // Atualiza o elemento de texto na tela do jogo (wave)
        StartCoroutine(SpawnWave()); // Reinicia a Coroutine
    }

    private void UpdateWaveText() // Atualiza o elemento de texto da wave
    {
        waveText.text = "Wave: " + currentWave.ToString(); // Concatena o curretWanve para atualizar o valor que aparecerá na tela com base no valor da wave atual
    }
}
```

- Button
```Csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Buttons : MonoBehaviour
{

// Todos os métodos abaixos servem unicamente para transitar entre as cenas do jogo, sendo assim, puxadas no "OnClick"
    public void StartGame()
    {
        SceneManager.LoadScene("Armazem");
    }

    public void QuitGame()
    {
        Debug.Log("Saindo do Jogo...");
        Application.Quit();
    }
    public void Menu()
    {
        SceneManager.LoadScene("Menu_Inicial");
    }
}
```

<br>

# UI do Jogo:
- Menu inicial
 Foi feito um Canvas para fazer o menu inicial, o qual pelo seu nome deixa a entender, será o primeiro que o jogador verá e permitirá que o mesmo escolha entre começar a jogatina ou sair do nosso jogo. Contém um material, o qual foi inserida uma imagem que havia sido feita no Canvas, a sua imagem estará abaixo:

- Menu pausa 
 O menu de pausa terá a única função de permitir que o nosso player consiga pausar o jogo quando quiser ou precisar. É um Canvas que é chamado quando a tecla "Esc" é clicada e que desaparece quando "Tab" é pressionado. O código está presente no script do jogador. Contém um material, o qual foi inserida uma imagem que havia sido feita no Canvas, a sua imagem estará abaixo:

- Menu gameover
 Como é de se imaginar, perder o nosso jogo, ou seja, chegar ao valor 0 de vidas, fará a ação de puxar o menu de gameover e permitirá o jogador decidir se vai reiniciar o jogo ou voltar ao menu inicial. Ocódigo está presente no script do jogador.
<br>

# Materials:
 As texturas citadas na tabela abaixo foram usadas para a composição de nossa cena, a qual é um armazém abandonado e situado por mais alguns edifícios que fazem parte do conjunto completo da região aonde a batalha ocorreria. Pegamos então, modelos de edifícios pre-modelados para "encher" (não deixar só uma cena com um piso e alguns muros) e transmitir uma sensação de um lugar mais "vivo" e com algum sentido, mesmo que não mais (por ser um armazém abandonado), para o universo em que o jogo se baseia. Para obstruir a passagem do jogador para fora do mapa, utilizamos de alguns modelos de veículos e muros, os quais estão desgastados/enferrujados pelo longo período sem utilidade ou uso, sendo os veículos sendo colocados estrategicamente nas entradas do armazém (o qual é cercado por alguns muros e tem uma rua passando em seu interior ) e mais um, nesse caso um caminhão, colocado dentro do armazém de lado e abandonado ao lado de algumas caçambas. No geral, nosso cenário utiliza-se de modelos pegos da AssetStore que transmitem ou apresentem uma sensação de "velho", "antigo" e "abandonado", o qual é o lugar para onde Sam e Mikaela fogem junto de Bumblebee.
 Agora, os personagens: como dito anteriormente na teoria das cores de nosso protagonista, Bumblebee, seu amarelo forte e imponente serve como uma forma do jogador distingui-lo do cenário e transmitir uma ideia de segurança e confiança visual. O nosso inimigo, composto predominantemente por cores mais frias e com uma textura de ferrugem, adjunto de uma luz vermelha em cima de sua cabeça, ressalta seu papel como adversário de Bumblebee e chama a atenção de nosso jogador.
  E sobre nossas texturas para os menus do jogo, elas foram feitas no Canvas e seus elementos são posicionados de forma estratégica para atrair a atenção do nosso jogador. Abaixo teremos uma tabela com cada material:
 
# Objetos/Cenário
| Textura | Imagem | 
| --- | --- | 
| Piso | ![image](https://github.com/user-attachments/assets/36cd2cf1-04d5-499f-b256-b538b3e10a46)|
| Muro | ![image](https://github.com/user-attachments/assets/115e2b22-88a5-4480-989f-83d79701bc28)| 
| Armazém |![image](https://github.com/user-attachments/assets/99cf47d6-08a9-48fb-aef6-425be88d79e1)|
| Rua Pavimentada |![image](https://github.com/user-attachments/assets/d4186f99-a146-49f8-b70e-24d5325538e3)| 
| Tanque de Óleo |![image](https://github.com/user-attachments/assets/9175fda8-0ae8-459f-a2a9-ef4beb5502c4)| 
| Ônibus | ![image](https://github.com/user-attachments/assets/bedee9b4-fa93-4fec-9efb-aa0554b06f44)|
| Lixeira | ![image](https://github.com/user-attachments/assets/7e05a41e-de8e-4948-9964-953ec388dbd3)| 
| Lixeira2 | ![image](https://github.com/user-attachments/assets/2384084b-d5f7-49f7-a19f-e49d66098a27)|
| Hangar1 | ![image](https://github.com/user-attachments/assets/b318f6df-8cf3-4280-a72d-130b4d129af5)| 
| Hangar2 | ![image](https://github.com/user-attachments/assets/4661477d-ad41-4feb-8061-b973658fd981)|
| Caminhão | ![image](https://github.com/user-attachments/assets/fe4c047c-fd7d-4337-b292-5eebe7089d93)|


# Personagens
| Textura | Imagem | 
| --- | --- |
| Bumbleebe1 | ![image](https://github.com/user-attachments/assets/179cd790-02c5-4827-aa7a-b3964f78cad9)| 
| Inimigo1 |  ![image](https://github.com/user-attachments/assets/20979302-5573-428b-8ffd-3805a9a2ab7e)  ![image](https://github.com/user-attachments/assets/cd32eb2b-46ec-4502-bf62-e0bf9cf5133a)| 

# Menu
| Textura | Imagem | 
| --- | --- | 
| Menu_Inicial | ![image](https://github.com/user-attachments/assets/ff84eed9-bca4-49c1-9386-ca5840443d65)| 
| Menu_GameOver | ![image](https://github.com/user-attachments/assets/439f1145-9765-4702-9bbb-64204148cafa)| 
| Menu_Pausa | ![image](https://github.com/user-attachments/assets/95560d2f-24c2-4b18-847e-a53436f3ba41)| 

<br>
_________________________________________________________________

# Arte Conceitual:

![image](https://github.com/user-attachments/assets/22be097d-81d7-42be-9e25-96e0783101c9)

<br>

# Diagrama UML:

## Original:

![Diagrama_UML_Transformers (4)](https://github.com/user-attachments/assets/14130709-ce3c-41f1-b172-3b6ec15f995e)

## Corrigido:

![Diagrama_UML_Transformers (5)](https://github.com/user-attachments/assets/495eb2ae-39aa-45da-b659-7a35211882e8)

<br>

_________________________________________________________________

# Descrição do Desenvolvimento do Projeto:
- Sobre o que foi feito em nosso projeto: de principal e mais importante, o sistema de waves e os projéteis. As waves foram feitas utilizando-se da Coroutine e de um looping para a instanciação de GameObjects (os inimigos) de forma períodica, ou seja, com um pequeno "timer" de wave para wave. Os inimigos são instanciados de um Prefab existente e escondido no mapa, o qual determina algumas características iniciais como: GameObjects no jogo que serão utilizados de base para o código, dentre outros mais simples como predefinir um valor para uma variável pela aba de propriedades ao lado. Os modelos, os efeitos e o projétil em si foi pego da AssetStore, adjunto dos efeitos de explosão. Além do modelo de projétil, pegamos também alguns outros modelos para a composição do cenário: Assets de edifícios abandonados ou velhos, alguns veículos, etc, os quais foram utilizados para montar a cena por ambos da dupla. Pegamos também algumas animações da Mixamo e adicionamos aos objetos 3D já feitos do site "NOME DO SITE", sendo necessário criar um esqueleto para esses modelos pois não haviam, ao menos para o unity.
  Após a principal parte do projeto ser feita, ou seja, cada um dos scripts e grande parte do mapa, foi-se direcionado o foco do projeto ao Readme de nosso GitHub e a correção de erros no jogo, organização dos arquivos, erros de nomeação e a produção do diagrama UML corrigido. Em resumo, focamos inicialmente nos códigos, utilizando-se de um mapa vazio para os testes enquanto criávamos o que seria utilizado na jogatina e após finalizado, inserirmos os modelos e os organizamos, depois só sendo necessário corrigir alguns erros básicos de movimentação, determinação de GameObjects (inserir pela tela de propriedades qual GameObject tal classe deveria puxar para o seu código) e de escrita. 
<br>

_________________________________________________________________

# Descrição da Organização e Execução das Tarefas:
Alex: Para mim, ambos da dupla trabalharam bem e participaram em todo o projeto ao todo, seja fazendo parte de toda a produção ou auxiliando na correção de problemas. A principal parte que fiz foi a visual (mapa), a codificação da Wave e do Inimigo (que depois viria a ser modificada pelo Felipe para funcionar com os projéteis), a parte da interface do jogo e a documentação de nosso projeto, além de procurar tentar ajudar e procurar ajuda quando precisava. No geral, o projeto foi bem desenvolvido e separado, buscando dividir as tarefas de forma que coincidissem com os pontos fortes de cada um, e claro, com cada um não se limitando somente na parte que mais tivesse facilidade, mas também auxiliando o outro quando houvesse necessidade.
Felipe: 

<br>

_________________________________________________________________

# Referências:

https://sketchfab.com/3d-models/transformers-2007-movie-bumblebee-1977-54454cddc885490f91c557851ec3f1db
https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v3-0-101429
https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679
https://assetstore.unity.com/packages/2d/textures-materials/sky/allsky-free-10-sky-skybox-set-146014
https://assetstore.unity.com/packages/vfx/particles/fire-explosions/hq-explosions-pack-free-263326
https://assetstore.unity.com/packages/3d/vehicles/land/school-bus-hq-70485
https://assetstore.unity.com/packages/vfx/particles/fire-explosions/fire-spell-effects-36825
https://assetstore.unity.com/packages/3d/environments/fantasy/fantasy-forest-environment-free-demo-35361
https://assetstore.unity.com/packages/3d/vehicles/land/low-poly-cars-101798
https://assetstore.unity.com/publishers/12124
https://assetstore.unity.com/publishers/3830
https://assetstore.unity.com/publishers/12124
https://assetstore.unity.com/publishers/6452
<br>
 
